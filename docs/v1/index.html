<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Production Line — Dark Dashboard</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1418; --muted:#9aa4ad; --accent:#7dd3fc; --card:#101519; --green:#34d399; --red:#fb7185; --yellow:#fbbf24; --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071018);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    .app{display:flex;height:100vh;color:#e6eef3}/* LEFT INFO BOX (1/4) */
.info-col{width:25%;min-width:300px;background:linear-gradient(180deg,var(--panel),#07121a);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);padding:20px;display:flex;flex-direction:column;gap:14px}
.brand{display:flex;align-items:center;gap:12px}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#60a5fa);display:flex;align-items:center;justify-content:center;color:#021025;font-weight:700}
h1{font-size:18px;margin:0}
p.lead{color:var(--muted);margin:0;font-size:13px}

/* small cards stack */
.cards{display:grid;grid-template-columns:1fr;gap:12px;overflow:auto;padding-right:6px}
.card{background:linear-gradient(180deg,var(--card), rgba(255,255,255,0.02));padding:12px;border-radius:10px;display:flex;align-items:center;justify-content:space-between;gap:12px;box-shadow:0 6px 18px rgba(2,6,10,0.6)}
.meta{display:flex;align-items:center;gap:12px}
.status-dot{width:12px;height:12px;border-radius:50%;box-shadow:0 0 6px rgba(0,0,0,0.6);flex-shrink:0}
.meta .name{font-size:13px}
.meta .sub{font-size:11px;color:var(--muted)}
.value{font-weight:700;font-size:15px;color:#fff}

/* switch */
.switch{position:relative;width:44px;height:24px;border-radius:999px;background:rgba(255,255,255,0.06);cursor:pointer}
.switch .knob{position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:50%;background:#fff;transition:all .22s}
.switch.on{background:linear-gradient(90deg,var(--green),#10b981)}
.switch.on .knob{left:23px}

/* right area for svg (3/4) */
.visual{flex:1;padding:24px}
.stage{height:100%;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;padding:18px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);display:flex;flex-direction:column}

.svg-wrap{flex:1;background:linear-gradient(180deg,#051014 0%, #07131a 100%);border-radius:10px;padding:12px;position:relative;overflow:hidden}

/* grid overlay small */\    
.grid-lines{position:absolute;inset:12px 12px 12px 12px;pointer-events:none}

svg{width:100%;height:100%}

/* nodes */
.station{fill:#071217;stroke:#16232b;stroke-width:2;rx:8;filter:drop-shadow(0 6px 12px rgba(0,0,0,0.6))}
.station .label{font-size:10px;fill:#d8eef6}

/* pipes */
.pipe{fill:none;stroke:#134e63;stroke-width:8;stroke-linecap:round;stroke-linejoin:round;opacity:0.9}
.pipe.flow{stroke:#1fb6ff;stroke-dasharray:40 140;animation:flow 3s linear infinite}
@keyframes flow{to{stroke-dashoffset:-180}}

/* hover effects */
.pipe:hover{stroke-width:10}
.station:hover{transform:translateY(-4px)}

/* legend */
.legend{display:flex;gap:12px;align-items:center;margin-top:10px;color:var(--muted);font-size:13px}
.dot{width:10px;height:10px;border-radius:50%}

/* scrollbar tiny */
.cards::-webkit-scrollbar{width:8px}
.cards::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#0b2830,#0a2a32);border-radius:8px}

/* responsive */
@media (max-width:900px){.info-col{display:none}}

  </style>
</head>
<body>
  <div class="app">
    <aside class="info-col">
      <div class="brand">
        <div class="logo">PL</div>
        <div>
          <h1>ProdLine Dashboard</h1>
          <p class="lead">Dark-mode visualization — 10×10 grid example</p>
        </div>
      </div><div class="cards" id="cards"></div>

  <div class="legend">
    <div style="display:flex;gap:8px;align-items:center"><div class="dot" style="background:var(--green)"></div>Running</div>
    <div style="display:flex;gap:8px;align-items:center"><div class="dot" style="background:var(--yellow)"></div>Warning</div>
    <div style="display:flex;gap:8px;align-items:center"><div class="dot" style="background:var(--red)"></div>Stopped</div>
  </div>
</aside>

<main class="visual">
  <div class="stage">
    <div style="display:flex;justify-content:space-between;align-items:center;color:var(--muted);margin-bottom:8px">
      <div>Factory Floor — Production Line Map</div>
      <div style="font-size:13px">Matrix: <strong>10 × 10</strong></div>
    </div>

    <div class="svg-wrap">
      <svg id="map" viewBox="0 0 1200 900" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="grid-lines" aria-hidden>
        <!-- optional grid overlay rendered by JS -->
      </div>
    </div>
  </div>
</main>

  </div>  <script>
    // Configuration of grid
    const cols = 10, rows = 10;
    const svg = document.getElementById('map');
    const W = 1200, H = 900;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    const padding = 80;
    const gridW = W - padding*2;
    const gridH = H - padding*2;
    const cellW = gridW / (cols-1);
    const cellH = gridH / (rows-1);

    // helper to compute center positions
    function pos(c,r){return {x: padding + c*cellW, y: padding + r*cellH}};

    // Create nodes placed on 10x10 (some may be inactive to avoid clutter, but all positions exist)
    const nodes = [];
    let id = 1;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const p = pos(c,r);
        const n = {id: `n${id++}`, c, r, x:p.x, y:p.y, status: ['running','running','warning','stopped'][Math.floor(Math.random()*4)], value: Math.floor(50+Math.random()*450)};
        nodes.push(n);
      }
    }

    // draw subtle grid points (optional)
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    gridGroup.setAttribute('opacity','0.06');
    nodes.forEach(n=>{
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
      dot.setAttribute('cx',n.x); dot.setAttribute('cy',n.y); dot.setAttribute('r',3);
      dot.setAttribute('fill','#0f2a37');
      gridGroup.appendChild(dot);
    });
    svg.appendChild(gridGroup);

    // create stations for a subset to keep visual clarity — we'll create every 2nd cell as station
    const stations = nodes.filter((_,i)=> i%2===0);

    const stationGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    stationGroup.setAttribute('id','stations');
    svg.appendChild(stationGroup);

    stations.forEach(s=>{
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('transform',`translate(${s.x-36},${s.y-20})`);
      g.setAttribute('class','station-wrap');
      // rect
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('width',72); rect.setAttribute('height',40); rect.setAttribute('rx',8); rect.setAttribute('class','station');
      // color border based on status
      const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
      border.setAttribute('width',72); border.setAttribute('height',40); border.setAttribute('rx',8); border.setAttribute('fill','none');
      border.setAttribute('stroke', s.status==='running'? 'rgba(52,211,153,0.12)' : s.status==='warning'? 'rgba(251,191,36,0.12)' : 'rgba(251,113,133,0.12)');
      border.setAttribute('stroke-width','3');

      // label
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x',36); label.setAttribute('y',22); label.setAttribute('text-anchor','middle'); label.setAttribute('class','label');
      label.textContent = s.id + ' ('+s.value+')';

      g.appendChild(rect); g.appendChild(border); g.appendChild(label);
      stationGroup.appendChild(g);

      // attach data
      g.dataset.id = s.id;
      g.dataset.status = s.status;
      g.addEventListener('mouseenter', ()=> g.style.transform = 'translateY(-6px)');
      g.addEventListener('mouseleave', ()=> g.style.transform = 'translateY(0)');
    });

    // create connections — a deterministic pseudo-random selection to make a complex network
    function rng(seed){ let s = seed; return ()=>{ s = (s * 1664525 + 1013904223) % 4294967296; return s/4294967296; }}
    const rand = rng(12345);

    const pipesGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    pipesGroup.setAttribute('id','pipes');
    svg.appendChild(pipesGroup);

    // We'll create several typical orthogonal shapes: I (straight), L, U, C, T
    function makeOrthPath(from,to,style){
      // from,to are {x,y}; style selects routing
      const pts = [];
      const margin = 12;
      pts.push([from.x, from.y]);
      if(style==='I'){
        // straight horizontal or vertical if same row/col otherwise do L
        if(Math.abs(from.x-to.x) < 1.0) pts.push([to.x,to.y]);
        else if(Math.abs(from.y-to.y) < 1.0) pts.push([to.x,to.y]);
        else pts.push([to.x, from.y], [to.x,to.y]);
      } else if(style==='L'){
        // simple L: horizontal then vertical
        pts.push([to.x, from.y]); pts.push([to.x,to.y]);
      } else if(style==='Z' || style==='C'){
        // a C/Z shaped path via an intermediate offset
        const midX = (from.x + to.x)/2 + (rand()-0.5)*cellW*0.6;
        pts.push([midX, from.y]); pts.push([midX, to.y]); pts.push([to.x, to.y]);
      } else if(style==='U'){
        // U-shape going down/up then across
        const out = (rand()>0.5? 1:-1) * cellH*0.6;
        pts.push([from.x, from.y + out]); pts.push([to.x, from.y + out]); pts.push([to.x, to.y]);
      } else if(style==='T'){
        // T junction: from to center column then split — we'll route to target and draw an extra stub to a neighboring node later
        const midY = from.y;
        pts.push([to.x, midY]); pts.push([to.x,to.y]);
      } else {
        pts.push([to.x,to.y]);
      }

      // generate path d with rounded-like corners (using L commands and rely on stroke-linejoin round)
      let d = `M ${pts[0][0]} ${pts[0][1]}`;
      for(let i=1;i<pts.length;i++) d += ` L ${pts[i][0]} ${pts[i][1]}`;
      return d;
    }

    // pick a bunch of pairs and draw
    const styles = ['I','L','C','U','T'];
    const pairs = [];
    // connect many stations to create network
    for(let i=0;i<stations.length;i++){
      const s = stations[i];
      // connect to up-to 3 targets
      const count = 1 + Math.floor(rand()*3);
      for(let k=0;k<count;k++){
        const j = Math.floor(rand()*stations.length);
        if(j===i) continue;
        pairs.push([s, stations[j], styles[Math.floor(rand()*styles.length)]]);
      }
    }

    // dedupe by key
    const seen = new Set();
    pairs.forEach(p=>{
      const a = p[0].id, b = p[1].id; if(a===b) return;
      const key = [a,b].sort().join('--'); if(seen.has(key)) return; seen.add(key);
      const d = makeOrthPath({x:p[0].x,y:p[0].y},{x:p[1].x,y:p[1].y}, p[2]);
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', d);
      path.classList.add('pipe');
      // randomly choose some pipes to have animated flow
      if(rand() > 0.4) path.classList.add('flow');
      pipesGroup.appendChild(path);

      // small dots at joints to emphasize rounded connections
      // parse d to get points
      const coords = d.split('L').map(s=>s.replace('M','').trim()).map(s=>{ const [x,y]=s.split(' ').map(Number); return {x,y}});
      coords.forEach(pt=>{
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',pt.x); c.setAttribute('cy',pt.y); c.setAttribute('r',3.2); c.setAttribute('fill','#0a2a33'); c.setAttribute('opacity','0.9');
        pipesGroup.appendChild(c);
      });
    });

    // Build left info-cards dynamically for some stations (choose a sample of 12)
    const cardsEl = document.getElementById('cards');
    const sample = [];
    for(let i=0;i<stations.length;i+=Math.floor(stations.length/12)) sample.push(stations[i]);

    sample.forEach(s=>{
      const card = document.createElement('div'); card.className='card';
      const meta = document.createElement('div'); meta.className='meta';
      const dot = document.createElement('div'); dot.className='status-dot';
      if(s.status==='running') dot.style.background = 'var(--green)';
      else if(s.status==='warning') dot.style.background = 'var(--yellow)';
      else dot.style.background = 'var(--red)';
      const nam = document.createElement('div'); nam.innerHTML = `<div class="name">${s.id}</div><div class="sub">pos ${s.c},${s.r}</div>`;
      meta.appendChild(dot); meta.appendChild(nam);
      const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='12px';
      const value = document.createElement('div'); value.className='value'; value.textContent = s.value;

      const sw = document.createElement('div'); sw.className='switch'; if(s.status==='running') sw.classList.add('on');
      const knob = document.createElement('div'); knob.className='knob'; sw.appendChild(knob);
      sw.addEventListener('click', ()=>{ sw.classList.toggle('on'); });

      right.appendChild(value); right.appendChild(sw);
      card.appendChild(meta); card.appendChild(right);
      cardsEl.appendChild(card);
    });

    // accessibility: add title
    const title = document.createElementNS('http://www.w3.org/2000/svg','title'); title.textContent = 'Production Line map — 10 by 10 grid with orthogonal rounded pipes'; svg.appendChild(title);

    // resize handling (keeps crispness simple by re-rendering viewBox) - not required but handy
    window.addEventListener('resize', ()=>{
      // keep viewBox static; nothing to do for now
    });

  </script></body>
</html>
